#!usr/bin/env python
# -*- coding:utf-8 -*-
# author: sfhong2020 time:2020/3/28


"""快速排序（有时称为分区交换排序）是一种高效的排序算法。由英国计算机科学家Tony Hoare
于1959年开发并于1961年发表，它在现在仍然是一种常用的排序算法。
如果实现方法恰当，它可以比主要竞争对手（归并排序和堆排序）快两到三倍。
其核心的思路是取第一个元素（或者最后一个元素）作为分界点，
把整个数组分成左右两侧，左边的元素小于或者等于分界点元素，而右边的元素大于分界点元素，
然后把分界点移到中间位置，对左右子数组分别进行递归，最后就能得到一个排序完成的数组。
当子数组只有一个或者没有元素的时候就结束这个递归过程。
其中最重要的是将整个数组根据分界点元素划分成左右两侧的逻辑，目前有两种算法，图片展示的是第一种。
"""
# 任意选取一个数据（通常选用数组的第一个数或最后一个数）作为关键数据，
# 然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。
# 快速排序是一种分治排序算法，采用了递归的方法。
#
# 原理：
# 1．先从数列中取出一个数作为基准数。
# 2．分区过程：将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
# 3．对左右区间重复第二步，直到各区间只有一个数。
def partion(arr, low, high):

    i = low-1   # 最小元素的索引先放到第一个位置左边
    pivot = arr[high]  # 选取最后一个元素作为基准数
    for j in range(low, high):
        if arr[j] <= pivot:  # 大的数直接跳过，等待i来换
            i += 1   # 换完了之后，i要继续更新右移！妙！
            arr[i], arr[j] = arr[j], arr[i]   # i 用于寻找比pivot小的数，找到了就开始和左边大于pivot的数换，
    arr[i+1], arr[high] = arr[high], arr[i+1]  # 走完一轮，将pivot中位数放到索引i的右边

    return i+1

def quick_sort(arr, low, high):
    if low < high:
        pi = partion(arr, low, high)
        quick_sort(arr, low, pi-1)
        quick_sort(arr, pi+1, high)

nums = [2,8,7,1,3,5,6,4]
quick_sort(nums, 0, len(nums)-1)
print(nums)


# 稳定性：快排是一种不稳定排序，比如基准值的前后都存在与基准值相同的元素，那么相同值就会被放在一边，这样就打乱了之前的相对顺序
#
# 比较性：因为排序时元素之间需要比较，所以是比较排序
#
# 时间复杂度：快排的时间复杂度为O(nlogn)
#
# 空间复杂度：排序时需要另外申请空间，并且随着数列规模增大而增大，其复杂度为：O(nlogn)
#
# 归并排序与快排 ：归并排序与快排两种排序思想都是分而治之，但是它们分解和合并的策略不一样：
# 归并是从中间直接将数列分成两个，而快排是比较后将小的放左边大的放右边，所以在合并的时候归并排序还是需要将两个数列重新再次排序，
# 而快排则是直接合并不再需要排序，所以快排比归并排序更高效一些，可以从示意图中比较二者之间的区别。
# 快速排序有一个缺点就是对于小规模的数据集性能不是很好。